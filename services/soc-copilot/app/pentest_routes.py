"""
Penetration Testing API Routes
AI-powered security testing for SOC audit control validation
"""
import logging
from datetime import datetime, date
from typing import List, Optional
from uuid import UUID

from fastapi import APIRouter, HTTPException, Depends, status
from pydantic import BaseModel, Field
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, func

from .config import settings
from .database import get_db, set_rls_context
from .models import User, UserRole
from .pentest_models import (
    PentestEngagement, PentestTarget, PentestScan, Vulnerability,
    ExploitAttempt, AIThreatIntel, PentestReport,
    PentestType, PentestStatus, VulnerabilitySeverity, VulnerabilityStatus,
    ScanType, ExploitResult
)

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/pentest", tags=["Penetration Testing"])


# ============================================================================
# PYDANTIC SCHEMAS
# ============================================================================

class PentestEngagementCreate(BaseModel):
    soc_engagement_id: Optional[UUID] = None
    pentest_name: str = Field(..., min_length=1, max_length=500)
    pentest_type: PentestType
    target_description: str
    in_scope_assets: List[str]
    out_of_scope_assets: Optional[List[str]] = []
    ip_ranges: Optional[List[str]] = []
    domain_names: Optional[List[str]] = []
    start_date: Optional[date] = None
    end_date: Optional[date] = None
    allowed_hours: Optional[str] = None
    lead_pentester_id: UUID
    rules_of_engagement: Optional[str] = None
    emergency_contact_name: Optional[str] = None
    emergency_contact_phone: Optional[str] = None
    enable_ai_scanning: bool = True
    enable_ai_threat_intel: bool = True


class PentestEngagementResponse(BaseModel):
    id: UUID
    pentest_name: str
    pentest_type: PentestType
    status: PentestStatus
    target_description: str
    authorized_at: Optional[datetime]
    start_date: Optional[date]
    end_date: Optional[date]
    created_at: datetime

    class Config:
        from_attributes = True


class PentestTargetCreate(BaseModel):
    target_name: str
    target_type: str
    ip_address: Optional[str] = None
    hostname: Optional[str] = None
    url: Optional[str] = None
    criticality: str = "MEDIUM"
    business_owner: Optional[str] = None
    description: Optional[str] = None


class VulnerabilityCreate(BaseModel):
    target_id: UUID
    vuln_title: str
    vuln_description: str
    severity: VulnerabilitySeverity
    cvss_score: Optional[float] = None
    cve_id: Optional[str] = None
    cwe_id: Optional[str] = None
    affected_component: Optional[str] = None
    vulnerability_type: Optional[str] = None
    proof_of_concept: Optional[str] = None
    remediation_recommendation: str
    related_control_objectives: Optional[List[UUID]] = []


class VulnerabilityResponse(BaseModel):
    id: UUID
    vuln_title: str
    severity: VulnerabilitySeverity
    cvss_score: Optional[float]
    cve_id: Optional[str]
    status: VulnerabilityStatus
    ai_risk_score: Optional[float]
    discovered_at: datetime

    class Config:
        from_attributes = True


class ScanRequest(BaseModel):
    target_id: UUID
    scan_type: ScanType
    scan_config: Optional[dict] = {}
    enable_ai_enhancement: bool = True


class AIThreatAnalysisRequest(BaseModel):
    engagement_id: UUID
    analyze_attack_surface: bool = True
    threat_intel_sources: Optional[List[str]] = ["mitre", "cve", "exploit_db"]


# ============================================================================
# DEPENDENCY: Get current user
# ============================================================================

from ..main import get_current_user  # Import from main.py


# ============================================================================
# PENTEST ENGAGEMENT MANAGEMENT
# ============================================================================

@router.post("/engagements", response_model=PentestEngagementResponse, status_code=status.HTTP_201_CREATED)
async def create_pentest_engagement(
    engagement_data: PentestEngagementCreate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Create a new penetration testing engagement

    **Authorization Required:** Written authorization from client is mandatory
    before any testing can begin.

    **Compliance:** Ensures all testing is authorized, scoped, and documented
    per security standards.
    """
    # Only CPA Partner or Audit Manager can create pentest engagements
    if current_user.role not in [UserRole.CPA_PARTNER, UserRole.AUDIT_MANAGER]:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only CPA Partners or Audit Managers can create penetration testing engagements"
        )

    new_engagement = PentestEngagement(
        soc_engagement_id=engagement_data.soc_engagement_id,
        pentest_name=engagement_data.pentest_name,
        pentest_type=engagement_data.pentest_type,
        status=PentestStatus.SCOPING,
        target_description=engagement_data.target_description,
        in_scope_assets=engagement_data.in_scope_assets,
        out_of_scope_assets=engagement_data.out_of_scope_assets,
        ip_ranges=engagement_data.ip_ranges,
        domain_names=engagement_data.domain_names,
        start_date=engagement_data.start_date,
        end_date=engagement_data.end_date,
        allowed_hours=engagement_data.allowed_hours,
        lead_pentester_id=engagement_data.lead_pentester_id,
        rules_of_engagement=engagement_data.rules_of_engagement,
        emergency_contact_name=engagement_data.emergency_contact_name,
        emergency_contact_phone=engagement_data.emergency_contact_phone,
        enable_ai_scanning=engagement_data.enable_ai_scanning,
        enable_ai_threat_intel=engagement_data.enable_ai_threat_intel,
        created_by=current_user.id
    )

    db.add(new_engagement)
    await db.commit()
    await db.refresh(new_engagement)

    logger.info(
        f"Created pentest engagement: {new_engagement.pentest_name} "
        f"(Type: {engagement_data.pentest_type.value}) by {current_user.email}"
    )

    return PentestEngagementResponse.model_validate(new_engagement)


@router.get("/engagements", response_model=List[PentestEngagementResponse])
async def list_pentest_engagements(
    status_filter: Optional[PentestStatus] = None,
    pentest_type: Optional[PentestType] = None,
    skip: int = 0,
    limit: int = 100,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """List all penetration testing engagements"""
    query = select(PentestEngagement)

    if status_filter:
        query = query.where(PentestEngagement.status == status_filter)

    if pentest_type:
        query = query.where(PentestEngagement.pentest_type == pentest_type)

    query = query.offset(skip).limit(limit).order_by(PentestEngagement.created_at.desc())

    result = await db.execute(query)
    engagements = result.scalars().all()

    return [PentestEngagementResponse.model_validate(eng) for eng in engagements]


@router.post("/engagements/{engagement_id}/authorize")
async def authorize_pentest(
    engagement_id: UUID,
    authorization_letter_path: str,
    authorization_expiry: datetime,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Authorize penetration testing engagement

    **Required:** Only CPA Partner can authorize. Authorization letter from
    client must be uploaded and reviewed.

    **Security:** This is a critical control point - no testing can proceed
    without proper authorization.
    """
    if current_user.role != UserRole.CPA_PARTNER:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only CPA Partners can authorize penetration testing"
        )

    result = await db.execute(
        select(PentestEngagement).where(PentestEngagement.id == engagement_id)
    )
    engagement = result.scalar_one_or_none()

    if not engagement:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Engagement not found")

    # Update authorization
    engagement.status = PentestStatus.AUTHORIZED
    engagement.authorization_letter_path = authorization_letter_path
    engagement.authorized_by = current_user.id
    engagement.authorized_at = datetime.utcnow()
    engagement.authorization_expiry = authorization_expiry

    await db.commit()

    logger.warning(
        f"⚠️ PENTEST AUTHORIZED: {engagement.pentest_name} by {current_user.email}. "
        f"Expiry: {authorization_expiry}"
    )

    return {
        "message": "Penetration testing engagement authorized",
        "engagement_id": str(engagement_id),
        "authorized_by": current_user.email,
        "authorization_expiry": authorization_expiry.isoformat()
    }


# ============================================================================
# TARGET MANAGEMENT
# ============================================================================

@router.post("/engagements/{engagement_id}/targets", status_code=status.HTTP_201_CREATED)
async def add_pentest_target(
    engagement_id: UUID,
    target_data: PentestTargetCreate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Add a target asset to penetration testing scope"""
    # Verify engagement exists
    result = await db.execute(
        select(PentestEngagement).where(PentestEngagement.id == engagement_id)
    )
    engagement = result.scalar_one_or_none()

    if not engagement:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Engagement not found")

    new_target = PentestTarget(
        pentest_engagement_id=engagement_id,
        target_name=target_data.target_name,
        target_type=target_data.target_type,
        ip_address=target_data.ip_address,
        hostname=target_data.hostname,
        url=target_data.url,
        criticality=target_data.criticality,
        business_owner=target_data.business_owner,
        description=target_data.description
    )

    db.add(new_target)
    await db.commit()
    await db.refresh(new_target)

    return new_target


@router.get("/engagements/{engagement_id}/targets")
async def list_pentest_targets(
    engagement_id: UUID,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """List all targets for a penetration testing engagement"""
    result = await db.execute(
        select(PentestTarget)
        .where(PentestTarget.pentest_engagement_id == engagement_id)
        .order_by(PentestTarget.criticality.desc())
    )
    targets = result.scalars().all()

    return targets


# ============================================================================
# AI-POWERED SCANNING
# ============================================================================

@router.post("/engagements/{engagement_id}/ai-scan")
async def run_ai_powered_scan(
    engagement_id: UUID,
    scan_request: ScanRequest,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Run AI-powered security scan

    **AI Capabilities:**
    - Automated vulnerability detection
    - CVE correlation and severity scoring
    - Attack surface analysis
    - Threat intelligence integration
    - Smart remediation recommendations

    **Compliance:** Maps findings to SOC control objectives
    """
    # Verify engagement is authorized
    result = await db.execute(
        select(PentestEngagement).where(PentestEngagement.id == engagement_id)
    )
    engagement = result.scalar_one_or_none()

    if not engagement:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Engagement not found")

    if engagement.status not in [PentestStatus.AUTHORIZED, PentestStatus.IN_PROGRESS]:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Engagement must be authorized before scanning"
        )

    # Create scan record
    new_scan = PentestScan(
        pentest_engagement_id=engagement_id,
        target_id=scan_request.target_id,
        scan_type=scan_request.scan_type,
        scan_name=f"AI-Enhanced {scan_request.scan_type.value}",
        scan_tool="custom_ai",
        scan_config=scan_request.scan_config,
        ai_enhanced=scan_request.enable_ai_enhancement,
        ai_model_used=settings.OPENAI_MODEL if scan_request.enable_ai_enhancement else None,
        status="IN_PROGRESS",
        started_at=datetime.utcnow(),
        executed_by=current_user.id
    )

    db.add(new_scan)
    await db.commit()
    await db.refresh(new_scan)

    # In production, this would trigger async scanning job
    logger.info(
        f"Started AI scan: {scan_request.scan_type.value} on target {scan_request.target_id} "
        f"for engagement {engagement_id}"
    )

    return {
        "message": "AI-powered scan initiated",
        "scan_id": str(new_scan.id),
        "scan_type": scan_request.scan_type.value,
        "ai_enhanced": scan_request.enable_ai_enhancement,
        "status": "IN_PROGRESS",
        "note": "Scan results will be available upon completion. Check scan status endpoint."
    }


@router.get("/scans/{scan_id}/status")
async def get_scan_status(
    scan_id: UUID,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Get penetration testing scan status and results"""
    result = await db.execute(
        select(PentestScan).where(PentestScan.id == scan_id)
    )
    scan = result.scalar_one_or_none()

    if not scan:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Scan not found")

    return {
        "scan_id": str(scan.id),
        "scan_type": scan.scan_type.value,
        "status": scan.status,
        "started_at": scan.started_at.isoformat() if scan.started_at else None,
        "completed_at": scan.completed_at.isoformat() if scan.completed_at else None,
        "duration_seconds": scan.duration_seconds,
        "findings_count": scan.findings_count,
        "severity_breakdown": {
            "critical": scan.critical_count,
            "high": scan.high_count,
            "medium": scan.medium_count,
            "low": scan.low_count,
            "info": scan.info_count
        },
        "ai_enhanced": scan.ai_enhanced,
        "ai_confidence_score": float(scan.ai_confidence_score) if scan.ai_confidence_score else None
    }


# ============================================================================
# VULNERABILITY MANAGEMENT
# ============================================================================

@router.post("/engagements/{engagement_id}/vulnerabilities", response_model=VulnerabilityResponse, status_code=status.HTTP_201_CREATED)
async def create_vulnerability(
    engagement_id: UUID,
    vuln_data: VulnerabilityCreate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Document a discovered vulnerability"""
    new_vuln = Vulnerability(
        pentest_engagement_id=engagement_id,
        target_id=vuln_data.target_id,
        vuln_title=vuln_data.vuln_title,
        vuln_description=vuln_data.vuln_description,
        severity=vuln_data.severity,
        cvss_score=vuln_data.cvss_score,
        cve_id=vuln_data.cve_id,
        cwe_id=vuln_data.cwe_id,
        affected_component=vuln_data.affected_component,
        vulnerability_type=vuln_data.vulnerability_type,
        proof_of_concept=vuln_data.proof_of_concept,
        remediation_recommendation=vuln_data.remediation_recommendation,
        related_control_objectives=[str(obj_id) for obj_id in vuln_data.related_control_objectives] if vuln_data.related_control_objectives else None,
        status=VulnerabilityStatus.OPEN,
        discovered_by=current_user.id
    )

    db.add(new_vuln)
    await db.commit()
    await db.refresh(new_vuln)

    logger.warning(
        f"⚠️ {vuln_data.severity.value} vulnerability discovered: {vuln_data.vuln_title} "
        f"in engagement {engagement_id}"
    )

    return VulnerabilityResponse.model_validate(new_vuln)


@router.get("/engagements/{engagement_id}/vulnerabilities", response_model=List[VulnerabilityResponse])
async def list_vulnerabilities(
    engagement_id: UUID,
    severity: Optional[VulnerabilitySeverity] = None,
    status_filter: Optional[VulnerabilityStatus] = None,
    skip: int = 0,
    limit: int = 100,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """List all vulnerabilities for an engagement"""
    query = select(Vulnerability).where(Vulnerability.pentest_engagement_id == engagement_id)

    if severity:
        query = query.where(Vulnerability.severity == severity)

    if status_filter:
        query = query.where(Vulnerability.status == status_filter)

    # Order by severity (critical first)
    query = query.order_by(
        Vulnerability.severity,
        Vulnerability.discovered_at.desc()
    ).offset(skip).limit(limit)

    result = await db.execute(query)
    vulnerabilities = result.scalars().all()

    return [VulnerabilityResponse.model_validate(v) for v in vulnerabilities]


@router.get("/engagements/{engagement_id}/dashboard")
async def get_pentest_dashboard(
    engagement_id: UUID,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Get penetration testing dashboard metrics

    Provides executive summary of security posture
    """
    # Get engagement
    eng_result = await db.execute(
        select(PentestEngagement).where(PentestEngagement.id == engagement_id)
    )
    engagement = eng_result.scalar_one_or_none()

    if not engagement:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Engagement not found")

    # Get vulnerability counts
    vuln_result = await db.execute(
        select(
            Vulnerability.severity,
            func.count(Vulnerability.id).label("count")
        )
        .where(Vulnerability.pentest_engagement_id == engagement_id)
        .group_by(Vulnerability.severity)
    )
    vuln_counts = {row[0].value: row[1] for row in vuln_result.fetchall()}

    # Get remediation status
    remediation_result = await db.execute(
        select(
            Vulnerability.status,
            func.count(Vulnerability.id).label("count")
        )
        .where(Vulnerability.pentest_engagement_id == engagement_id)
        .group_by(Vulnerability.status)
    )
    remediation_counts = {row[0].value: row[1] for row in remediation_result.fetchall()}

    # Get target count
    target_result = await db.execute(
        select(func.count(PentestTarget.id))
        .where(PentestTarget.pentest_engagement_id == engagement_id)
    )
    target_count = target_result.scalar()

    # Get scan count
    scan_result = await db.execute(
        select(func.count(PentestScan.id))
        .where(PentestScan.pentest_engagement_id == engagement_id)
    )
    scan_count = scan_result.scalar()

    return {
        "engagement_id": str(engagement_id),
        "engagement_name": engagement.pentest_name,
        "status": engagement.status.value,
        "pentest_type": engagement.pentest_type.value,
        "authorized_at": engagement.authorized_at.isoformat() if engagement.authorized_at else None,
        "metrics": {
            "targets_scanned": target_count,
            "scans_performed": scan_count,
            "total_vulnerabilities": sum(vuln_counts.values()),
            "vulnerabilities_by_severity": {
                "critical": vuln_counts.get("CRITICAL", 0),
                "high": vuln_counts.get("HIGH", 0),
                "medium": vuln_counts.get("MEDIUM", 0),
                "low": vuln_counts.get("LOW", 0),
                "info": vuln_counts.get("INFO", 0)
            },
            "remediation_status": remediation_counts
        },
        "ai_insights_enabled": engagement.enable_ai_scanning
    }


# ============================================================================
# AI THREAT INTELLIGENCE
# ============================================================================

@router.post("/engagements/{engagement_id}/ai-threat-analysis")
async def run_ai_threat_analysis(
    engagement_id: UUID,
    analysis_request: AIThreatAnalysisRequest,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Run AI-powered threat intelligence analysis

    **AI Capabilities:**
    - Attack surface discovery and analysis
    - Threat actor profiling
    - MITRE ATT&CK technique mapping
    - Emerging threat detection
    - Risk prioritization

    **Integration:** Correlates with CVE databases, exploit databases,
    and threat intelligence feeds
    """
    # Verify engagement
    result = await db.execute(
        select(PentestEngagement).where(PentestEngagement.id == engagement_id)
    )
    engagement = result.scalar_one_or_none()

    if not engagement:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Engagement not found")

    if not engagement.enable_ai_threat_intel:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="AI threat intelligence is not enabled for this engagement"
        )

    logger.info(
        f"Initiated AI threat analysis for engagement {engagement_id} "
        f"with sources: {analysis_request.threat_intel_sources}"
    )

    # In production, this would trigger async AI analysis
    return {
        "message": "AI threat intelligence analysis initiated",
        "engagement_id": str(engagement_id),
        "analysis_type": "COMPREHENSIVE",
        "threat_intel_sources": analysis_request.threat_intel_sources,
        "attack_surface_analysis": analysis_request.analyze_attack_surface,
        "status": "IN_PROGRESS",
        "note": "Analysis results will be available in the AI threat intelligence endpoint"
    }


@router.get("/engagements/{engagement_id}/ai-threats")
async def get_ai_threat_intelligence(
    engagement_id: UUID,
    min_confidence: float = 0.70,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Get AI-detected threats and intelligence"""
    result = await db.execute(
        select(AIThreatIntel)
        .where(
            and_(
                AIThreatIntel.pentest_engagement_id == engagement_id,
                AIThreatIntel.confidence_score >= min_confidence
            )
        )
        .order_by(AIThreatIntel.confidence_score.desc())
    )
    threats = result.scalars().all()

    return [
        {
            "threat_name": threat.threat_name,
            "threat_type": threat.threat_type,
            "confidence_score": float(threat.confidence_score),
            "description": threat.description,
            "mitre_attack_techniques": threat.mitre_attack_techniques,
            "overall_risk_rating": threat.overall_risk_rating,
            "ai_recommended_actions": threat.ai_recommended_actions,
            "detected_at": threat.detected_at.isoformat()
        }
        for threat in threats
    ]
