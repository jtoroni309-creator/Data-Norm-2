name: Deploy to Azure

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        type: choice
        options:
          - dev
          - staging
          - prod
        default: 'dev'

env:
  AZURE_RESOURCE_GROUP: aura-audit-ai-prod-rg
  AKS_CLUSTER_NAME: aura-audit-ai-prod-aks
  ACR_NAME: auraauditaiprodacr
  TERRAFORM_VERSION: 1.7.0

jobs:
  # Build and push Docker images to ACR
  build-and-push:
    name: Build & Push Images
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    strategy:
      matrix:
        service:
          - identity
          - ingestion
          - normalize
          - analytics
          - llm
          - engagement
          - disclosures
          - reporting
          - qc
          - connectors
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Login to ACR
        run: |
          az acr login --name ${{ env.ACR_NAME }}

      - name: Get short SHA
        id: vars
        run: echo "SHORT_SHA=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

      - name: Build and push image
        run: |
          docker build -t ${{ env.ACR_NAME }}.azurecr.io/aura/${{ matrix.service }}:${{ steps.vars.outputs.SHORT_SHA }} \
            -t ${{ env.ACR_NAME }}.azurecr.io/aura/${{ matrix.service }}:latest \
            -f services/${{ matrix.service }}/Dockerfile \
            services/${{ matrix.service }}

          docker push ${{ env.ACR_NAME }}.azurecr.io/aura/${{ matrix.service }}:${{ steps.vars.outputs.SHORT_SHA }}
          docker push ${{ env.ACR_NAME }}.azurecr.io/aura/${{ matrix.service }}:latest

  # Build and push frontend
  build-frontend:
    name: Build & Push Frontend
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Login to ACR
        run: |
          az acr login --name ${{ env.ACR_NAME }}

      - name: Get short SHA
        id: vars
        run: echo "SHORT_SHA=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

      - name: Build and push frontend image
        run: |
          docker build -t ${{ env.ACR_NAME }}.azurecr.io/aura/web:${{ steps.vars.outputs.SHORT_SHA }} \
            -t ${{ env.ACR_NAME }}.azurecr.io/aura/web:latest \
            frontend/

          docker push ${{ env.ACR_NAME }}.azurecr.io/aura/web:${{ steps.vars.outputs.SHORT_SHA }}
          docker push ${{ env.ACR_NAME }}.azurecr.io/aura/web:latest

  # Deploy infrastructure with Terraform
  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: [build-and-push, build-frontend]
    permissions:
      contents: read
      id-token: write
    outputs:
      postgres_host: ${{ steps.terraform.outputs.postgres_fqdn }}
      redis_host: ${{ steps.terraform.outputs.redis_hostname }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false

      - name: Terraform Init
        working-directory: infra/azure
        run: terraform init

      - name: Terraform Plan
        working-directory: infra/azure
        run: |
          terraform plan \
            -var="environment=prod" \
            -var="location=eastus" \
            -out=tfplan

      - name: Terraform Apply
        working-directory: infra/azure
        run: terraform apply -auto-approve tfplan

      - name: Get Terraform Outputs
        id: terraform
        working-directory: infra/azure
        run: |
          echo "postgres_fqdn=$(terraform output -raw postgres_fqdn)" >> $GITHUB_OUTPUT
          echo "redis_hostname=$(terraform output -raw redis_hostname)" >> $GITHUB_OUTPUT
          echo "storage_account=$(terraform output -raw storage_account_name)" >> $GITHUB_OUTPUT
          echo "key_vault=$(terraform output -raw key_vault_name)" >> $GITHUB_OUTPUT

  # Deploy to Kubernetes
  deploy-kubernetes:
    name: Deploy to AKS
    runs-on: ubuntu-latest
    needs: deploy-infrastructure
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER_NAME }} \
            --overwrite-existing

      - name: Get short SHA
        id: vars
        run: echo "SHORT_SHA=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

      - name: Get Azure resource values
        id: azure_values
        run: |
          # Get PostgreSQL password from Key Vault
          POSTGRES_PASSWORD=$(az keyvault secret show \
            --vault-name $(terraform output -raw key_vault_name) \
            --name postgres-admin-password \
            --query value -o tsv)

          # Get Redis key
          REDIS_KEY=$(az keyvault secret show \
            --vault-name $(terraform output -raw key_vault_name) \
            --name redis-primary-key \
            --query value -o tsv)

          echo "::add-mask::$POSTGRES_PASSWORD"
          echo "::add-mask::$REDIS_KEY"

          echo "POSTGRES_PASSWORD=$POSTGRES_PASSWORD" >> $GITHUB_ENV
          echo "REDIS_KEY=$REDIS_KEY" >> $GITHUB_ENV

      - name: Create namespace
        run: |
          kubectl apply -f infra/k8s/base/namespace.yaml

      - name: Create secrets
        run: |
          # Database connection secret
          kubectl create secret generic aura-db-connection \
            --from-literal=connection-string="postgresql+asyncpg://atlasadmin:${POSTGRES_PASSWORD}@${{ needs.deploy-infrastructure.outputs.postgres_host }}:5432/atlas?sslmode=require" \
            --from-literal=host="${{ needs.deploy-infrastructure.outputs.postgres_host }}" \
            --from-literal=username="atlasadmin" \
            --from-literal=password="${POSTGRES_PASSWORD}" \
            --namespace=aura-audit-ai \
            --dry-run=client -o yaml | kubectl apply -f -

          # Redis connection secret
          kubectl create secret generic aura-redis-connection \
            --from-literal=connection-string="rediss://:${REDIS_KEY}@${{ needs.deploy-infrastructure.outputs.redis_host }}:6380/0?ssl_cert_reqs=required" \
            --from-literal=host="${{ needs.deploy-infrastructure.outputs.redis_host }}" \
            --from-literal=password="${REDIS_KEY}" \
            --namespace=aura-audit-ai \
            --dry-run=client -o yaml | kubectl apply -f -

          # OpenAI secret
          kubectl create secret generic aura-openai \
            --from-literal=api-key="${{ secrets.OPENAI_API_KEY }}" \
            --namespace=aura-audit-ai \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Apply ConfigMap
        run: |
          kubectl apply -f infra/k8s/base/configmap.yaml

      - name: Apply Service Account
        run: |
          kubectl apply -f infra/k8s/base/serviceaccount.yaml

      - name: Deploy services
        run: |
          # Replace image tags with current SHA
          export ACR_NAME=${{ env.ACR_NAME }}
          export IMAGE_TAG=${{ steps.vars.outputs.SHORT_SHA }}

          envsubst < infra/k8s/base/deployment-identity.yaml | kubectl apply -f -
          envsubst < infra/k8s/base/deployments-all-services.yaml | kubectl apply -f -

      - name: Apply Ingress
        run: |
          kubectl apply -f infra/k8s/base/ingress.yaml

      - name: Wait for deployments
        run: |
          kubectl rollout status deployment/identity -n aura-audit-ai --timeout=5m
          kubectl rollout status deployment/llm -n aura-audit-ai --timeout=5m
          kubectl rollout status deployment/analytics -n aura-audit-ai --timeout=5m
          kubectl rollout status deployment/normalize -n aura-audit-ai --timeout=5m

      - name: Get deployment status
        run: |
          kubectl get pods -n aura-audit-ai
          kubectl get services -n aura-audit-ai
          kubectl get ingress -n aura-audit-ai

  # Run database migrations
  run-migrations:
    name: Run Database Migrations
    runs-on: ubuntu-latest
    needs: deploy-kubernetes
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER_NAME }} \
            --overwrite-existing

      - name: Run migrations via kubectl
        run: |
          # Run migration job (if you have migration scripts)
          # kubectl apply -f infra/k8s/jobs/migration.yaml

  # Smoke tests
  smoke-tests:
    name: Smoke Tests
    runs-on: ubuntu-latest
    needs: run-migrations
    permissions:
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get Application Gateway IP
        id: appgw_ip
        run: |
          IP=$(az network public-ip show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name aura-audit-ai-prod-appgw-pip \
            --query ipAddress -o tsv)
          echo "APPGW_IP=$IP" >> $GITHUB_OUTPUT

      - name: Test health endpoints
        run: |
          # Test API health
          curl -f http://${{ steps.appgw_ip.outputs.APPGW_IP }}/health || exit 1

          # Test individual services
          services=("identity" "llm" "analytics" "normalize")
          for service in "${services[@]}"; do
            echo "Testing $service..."
            curl -f http://${{ steps.appgw_ip.outputs.APPGW_IP }}/api/$service/health || exit 1
          done

      - name: Notify deployment success
        if: success()
        run: |
          echo "‚úÖ Deployment successful!"
          echo "üåê Application Gateway IP: ${{ steps.appgw_ip.outputs.APPGW_IP }}"
          echo "üìä Monitor: https://portal.azure.com"

      - name: Notify deployment failure
        if: failure()
        run: |
          echo "‚ùå Deployment failed!"
          exit 1
